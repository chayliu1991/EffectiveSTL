# 使用reserve来避免不必要的重新分配

```
int test_item_14()
{
	std::vector<int> v;
	//@ 如果不使用reserve,下面的循环在进行过程中将导致多次重新分配
	//@ 加上reserve，则在循环过程中,将不会再发生重新分配
	v.reserve(1000); 
	for (int i = 1; i <= 1000; ++i) v.push_back(i); 
	return 0;
}
```

对于 `vector` 和 `string`，增长过程是这样来实现的：

- 分配一块儿原内存大小数倍的新内存，对于 `vector` 和 `string` 而言，通常是两倍
- 将原来容器中的元素拷贝到新内存中
- 析构旧内存中的对象
- 释放旧内存

`reserve` 成员函数能使你把重新分配的次数减少到最低限度，从而避免了重新分配和指针/迭代器/引用失效带来的开销。避免重新分配的关键在于，尽早地使用 `reserve`，把容器的容量设为足够大的值，最好是在容器刚被构造出来之后就使用 `reserve`。

`reserve` 以及与 `reserve` 相关的几个函数：

- `size()` 容器中现有的元素的个数

- `capacity()` 容器在不重新分配内存的情况下可容纳元素的总个数

- `resize(Container::size_type n)` 将容器的 `size` 强制改变为 `n ` 

- - `n>size` 将现有容器中的元素拷贝到新内存，并将空余部分用默认构造的新函数填满
  - `n<size` 将尾部的元素全部析构掉

- `reserve(Container::size_type n)` 将容器的 `size` 改变至少为 `n`

- - `n>size` 将现有容器中的元素拷贝到新内存，多余部分的内存仍然空置
  - `n<size` 对容器没有影响

通常有两种方式使用 `reserve` 避免不必要的内存分配：

- 预测大致所需的内存，并在构造容器之后就调用 `reserve` 预留内存
- 先用 `reserve` 分配足够大的内存，将所有元素都加入到容器之后再去除多余内存

