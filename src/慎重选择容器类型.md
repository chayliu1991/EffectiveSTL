# 慎重选择容器类型

C++所提供的容器类型有如下几种：

- 标准 STL 序列容器：`vector`、`string`、`deque`、`list`、`forward_list`(C++11)、`array`(C++11)

- 标准 STL 关联容器：`set`、`multiset`、`map`、`multimap`、`unordered_set`(C++11)、`unordered_multiset`(C++11)、`unordered_map`(C++11)、`unordered_multimap`(C++11)
- 标准的非 STL 容器：包括：`bitset`、`valarray`
- STL 容器适配器：`stack`、`queue`、`priority_queue`

`vector<char>` 可以作为 `string` 的替代。

`vector` 是默认应使用的序列类型，当需要频繁地在序列中间做插入和删除操作时，应使用 `list`；当大部分插入和删除操作发生在序列的头部和尾部时，` deque` 是应考虑的数据结构。

STL 容器的一种分类方法：连续内存容器和基于节点的容器：

标准的连续内存容器有 `vector`、`string`、`deque`。连续内存容器(或称为基于数组的容器)把它的元素存放在一块或多块(动态分配的)内存中，每块内存中存有多个元素。当有新元素插入或已有的元素被删除时，同一内存块中的其它元素要向前或向后移动，以便为新元素让出空间，或者填充被删除元素所留下的空隙，这种移动影响到效率和异常安全性。

基于节点的容器在每一个(动态分配的)内存块中只存放一个元素。容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时，元素的值不需要移动。表示链表的容器，比如 `list`、`forward_list` 是基于节点的；所有的标准关联容器也是如此(通常的实现方式是平衡树)。标准的哈希容器使用不同的基于节点的实现。
选择容

器时最重要的一些问题：

- 你是否需要在容器的任意位置插入新元素？如果需要，就选择序列容器；关联容器是不行的。
- 你是否关心容器中的元素是如何排序的？如果不关心，则哈希容器是一个可行的选择方案；否则，你要避免哈希容器。
- 你选择的容器必须是标准C++的一部分吗？如果必须是，就排除了 `slist` 和 `rope`。
- 你需要哪种类型的迭代器？如果它们必须是随机访问迭代器，则对容器的选择就被限定为 `vector`、`deque` 和`string`。或许你也可以考虑 `rope`。如果要求使用双向迭代器，那么你必须避免 `slist` 以及哈希容器的一个常见实现。
- 当发生元素的插入或删除操作时，避免移动容器中原来的元素是否很重要？如果是，就要避免连续内存的容器。
- 容器中数据的布局是否需要和 C 兼容？如果需要兼容，就只能选择 `vector`。
- 元素的查找速度是否是关键的考虑因素？如果是，就要考虑哈希容器、排序的 `vector` 和标准关联容器。
- 如果容器内部使用了引用计数技术，你是否介意？如果是，就要避免使用 `string`，因为许多 `string` 的实现都使用了引用计数。`rope` 也需要避免，因为权威的 `rope` 实现是基于引用计数的。当然，你需要某种表示字符串的方法，这时你可以考虑 `vector<char>`。
- 对插入和删除操作，你需要事务语义吗？也就是说，在插入和删除操作失败时，你需要回滚的能力吗？如果需要，你就要使用基于节点的容器。如果对多个元素的插入操作(即针对一个区间的形式)需要事务语义，则你需要选择 `list`，因为在标准容器中，只有 `list` 对多个元素的插入操作提供了事务语义。对那些希望编写异常安全代码的程序员，事务语义显得尤为重要。(使用连续内存的容器也可以获得事务语义，但是要付出性能上的代价，而且代码也显得不那么直截了当。)
- 你需要使迭代器、指针和引用变为无效的次数最少吗？如果是这样，就要使用基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变得无效(除非它们指向了一个你正在删除的元素)。而针对连续内存容器的插入和删除操作一般会使指向该容器的迭代器、指针和引用变得无效。
- 如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，则指向数据的指针和引用就不会变为无效，这样的容器是否对你有帮助？这是非常特殊的情形，但如果你面对的情形正是如此，则 `deque` 是你所希望的容器。(当插入操作仅在容器末尾发生时，`deque` 的迭代器有可能会变为无效。`deque` 是唯一的、迭代器可能会变为无效而指针和引用不会变为无效的 STL 标准容器。)
  



