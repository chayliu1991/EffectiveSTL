# 了解哪些算法要求使用排序的区间作为参数

并非所有的算法都可以应用于任何区间。举例来说，`remove` 算法要求单向迭代器并且要求可以通过这些迭代器向容器中的对象赋值。所以，它不能用于由输入迭代器指定的区间，也不适用于 `map` 或 `multimap`，同样不适用于某些 `set` 和`multiset` 的实现。同样地，很多排序算法要求随机访问迭代器，所以对于 `list` 的元素不可能调用这些算法。有些算法要求排序的区间，即区间中的值是排过序的。有些算法既可以与排序的区间一起工作，也可以与未排序的区间一起工作，但是当它们作用在排序的区间上时，算法会更加有效。

要求排序区间的 STL 算法：`binaray_search`、`lower_bound`、`upper_bound`、`equal_range`、`set_union`、`set_intersection`、`set_difference`、`set_symmetric_difference`、`merge`、`inplace_merge`、`includes`。

`unique`、`unique_copy` 并不一定要求排序的区间，但通常情况下会与排序区间一起使用。

- 用于查找的算法 `binaray_search`、`lower_bound`、`upper_bound`、`equal_range` 要求排序的区间，因为它们用二分法查找数据。实际上，这些算法并不一定保证对数时间的查找效率。只有当它们接受了随机访问迭代器的时候，它们才保证有这样的效率。
- `set_union`、`set_intersection`、`set_difference`、`set_symmetric_difference` 这4个算法提供了线性时间效率的集合操作。如果它们不满足排序的区域的要求，它们就无法在线性时间内完成工作。
- `merge` 和 `inplace_merge` 实际上实现了合并和排序的联合操作：它们读入两个排序的区间，然后合并成一个新的排序区间，其中包含了原来两个区间中的所有元素。它们具有线性时间的性能，但如果它们不知道源区间已经排过序的话，它们就不可能在线性时间内完成。` 
-  `最后一个要求排序源区间的算法是 `includes`，它可用来判断一个区间中的所有对象是否都在另一个区间中。因为`includes` 总是假设这两个区间是排序的，所以它承诺线性时间的效率。如果没有这一前提的话，它通常会运行得更慢。
-  `unique` 和 `unique_copy` 与上述讨论过的算法有所不同，它们即使对于未排序的区间也有很好的行为。`unique` 使用了与 `remove` 类似的办法来删除区间中的元素，而并非真正意义上的删除。

如果你为一个算法提供了一个排序的区间，而这个算法也带一个比较函数作为参数，那么，你一定要保证你传递的比较函数与这个排序区间所用的比较函数有一致的行为。