# 容器的成员函数优先于同名的算法

有些 STL 容器提供了一些与算法同名的成员函数。比如，关联容器提供了 `count`、`find`、`lower_bound`、`upper_bound` 和 `equal_range`，而list则提供了 `remove`、`remove_if`、`unique`、`sort`、`merge` 和 `reverse`。大多数情况下，你应该使用这些成员函数，而不是相应的 STL 算法。这里有两个理由：第一，成员函数往往速度快；第二，成员函数通常与容器(特别是关联容器)结合得更加紧密，这是算法所不能比的。原因在于，算法和成员函数虽然有同样的名称，但是它们所做的事情往往不完全相同。

对于标准的关联容器，选择成员函数而不选择对应的同名算法，这可以带来几方面的好处：

- 第一，你可以获得对数时间的性能，而不是线性时间的性能。
- 第二，你可以使用等价性来确定两个值是否”相同”，而等价性是关联容器的一个本质定义。
- 第三，你在使用 `map` 和 `multimap` 的时候，将很自然地只考虑元素的键部分，而不是完整的(`key`, `value`)对。

`remove`、`remove_if`、`unique`、`sort`、`merge` 以及 `reverse` 这些算法无一例外地需要拷贝list容器中的对象，而专门为 `list` 容器量身定做的成员函数则无需任何对象拷贝，它们只是简单地维护好那些将list节点连接起来的指针。`list` 成员函数的行为不同于与其同名的算法的行为。如果真的要从一个容器中删除对象的话，你在调用了 `remove`、`remove_if` 或者 `unique` 算法之后，必须紧接着再调用 `erase`；而 `list` 的 `remove`、`remove_if` 和 `unique` 成员函数则实实在在地删除了元素，所以你无需再调用 `erase` 了。在 `sort` 算法与 `list` 的 `sort` 函数之间有一个很重要的区别是，前者根本不能被应用到 `list` 容器上，这是因为，`list` 的迭代器是双向迭代器，而 `sort` 算法要求随机访问迭代器。在 `merge` 算法和 `list` 的 `merge` 函数之间也存在行为上的隔阂：`merge` 算法是不允许修改其源区间的，而 `list::merge` 则总是在修改它所操作的链表。

